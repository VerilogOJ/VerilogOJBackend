config={'submission_id': 0, 'testcase_id': 0, 'submission_detail': {'id': 0, 'problem': {'id': 0, 'problem_files': [{'uuid': '4'}], 'testcase_id': 0}, 'user': {'id': 0, 'student_id': 'PB17000232'}, 'submit_time': '20101001', 'submit_files': [{'uuid': '5'}], 'testcase_files': [{'uuid': '0'}, {'uuid': '1'}, {'uuid': '2'}, {'uuid': '3'}]}, 'file_map': {'0': {'filename': 'main.sh', 'content': b'#!/bin/bash\niverilog ./testcase/testbench.v ./problem/decoder_ref.v -o ref_run\nvvp ref_run\nmv out.vcd out_ref.vcd\n\niverilog ./testcase/testbench.v ./submit/decoder.v -o dut_run\nvvp dut_run\nmv out.vcd out_dut.vcd\n\npython3 ./testcase/vcd_main.py         # This will compare out_ref.vcd and out_dut.vcd\n\nif [ $? -ne 0 ]; then\n  echo "0" > score.txt\nelse\n  echo "1" > score.txt\nfi\n'}, '1': {'filename': 'testbench.v', 'content': b'\nmodule testbench();\n    reg [2:0] x;\n    wire [7:0] y;\n    decoder DUT(x, y);\n\n    // http://www.referencedesigner.com/tutorials/verilog/verilog_62.php\n    initial begin\n        $dumpfile("out.vcd");\n        // This will dump all signal, which may not be useful\n        //$dumpvars;\n\n        // dumping only this module\n        //$dumpvars(1, testbench);\n\n        // dumping only these variable\n        // the first number (level) is actually useless\n        $dumpvars(0, x, y);\n    end\n\n    integer i;\n    initial begin\n        for (i = 0; i < 8; i = i + 1) begin\n            #1 x = i;\n        end\n    end\n\nendmodule\n'}, '2': {'filename': 'vcd_main.py', 'content': b'#!/usr/bin/env python3\nimport sys\n\ndef main():\n\n    from wavedump import VcdComparator\n    cmpr = VcdComparator("./out_ref.vcd", "./out_dut.vcd", [\'root/testbench/x\', \'root/testbench/y\'])\n    ret, msg = cmpr.compare()\n    return (ret, msg)\n\nret, msg = main()\nprint(msg)\nprint("Ret status: {}".format(ret))\nsys.exit(0 if ret is True else 1)\n'}, '3': {'filename': 'wavedump.py', 'content': b'#!/usr/bin/env python3\n\nfrom pyDigitalWaveTools.vcd.parser import VcdParser\n\nclass VcdSignalTraversalError(Exception):\n    pass\n\nclass VcdSignalComparationError(Exception):\n    pass\n\nclass VcdComparator:\n    def find_signal_inst(self, data_obj, signal_path):\n        components = signal_path.split("/")\n        cur = data_obj\n        for i in range(0, len(components) - 1):\n            if cur[\'name\'] != components[i]:\n                raise VcdSignalTraversalError("{} mismatch with {} while traversing {}".format(\n                    cur[\'name\'], components[i], signal_path))\n            \n            if not \'children\' in cur.keys():\n                raise VcdSignalTraversalError("{} have no data k-v pair while traversing {}".format(\n                    cur[\'name\'], signal_path))\n            \n            found = False\n            for child in cur[\'children\']:\n                if child[\'name\'] == components[i+1]:\n                    found = True\n                    cur = child\n                    break\n            \n            if not found:\n                raise VcdSignalTraversalError("{} have no children called {} while traversing {}".format(\n                    cur[\'name\'], components[i+1], signal_path))\n\n        if cur[\'name\'] != components[-1]:\n            raise VcdSignalTraversalError("{} mismatch with {} while traversing {}".format(\n                cur[\'name\'], components[-1], signal_path))\n\n        return cur\n\n    def compare_signals(self, ref, ud):\n        # compare width\n        if ref[\'type\'][\'width\'] != ud[\'type\'][\'width\']:\n            raise VcdSignalComparationError("Signal {} have different width between ref ({}) and ud ({})".format(\n                ref[\'name\'], ref[\'type\'][\'width\'], ud[\'type\'][\'width\']))\n        \n        # No need to compare sigType (reg/wire.. anything else?)\n\n        # signal comparation\n        # TODO: support for different types (\'b0\' with \'b000\' or \'d0\' or something...)\n        \n        # Since value change dump theoretically only generates data when changes\n        # so direct diffing should work\n        for i, val in enumerate(ref[\'data\']):\n            if ud[\'data\'][i] != val:\n                raise VcdSignalComparationError("Signal {} have difference on time {} (ref={}, ud={})".format(\n                    ref[\'name\'], val[0], val, ud[\'data\'][i]))\n\n    def dump_hierarchy(self, data_obj):\n        # TODO: only dump names\n        print(data_obj.toJSON())\n\n    def __init__(self, vcd_ref, vcd_ut, signal_names):\n        """Initialize signals for comparation\n        vcd_ref: the reference vcd file\n        vcd_ut: the vcd file under test\n        signal_names: the signal for comparation, uses "/" to express hierarchy.\n                 and the top module name shall also be included.\n        """\n\n        with open(vcd_ref) as vcd_ref_file:\n            vcd = VcdParser()\n            vcd.parse(vcd_ref_file)\n            self.data_ref = vcd.scope.toJson()\n            print(self.data_ref)\n\n        with open(vcd_ut) as vcd_ut_file:\n            vcd_ut = VcdParser()\n            vcd_ut.parse(vcd_ut_file)\n            self.data_ut = vcd_ut.scope.toJson()\n            print(self.data_ut)\n\n        # find all signals\n        self.signals_ref = [self.find_signal_inst(self.data_ref, i) for i in signal_names]\n        self.signals_ut = [self.find_signal_inst(self.data_ut, i) for i in signal_names]\n    \n    def compare(self):\n        try:\n            # compare all signals\n            for i in range(0, len(self.signals_ref)):\n                self.compare_signals(self.signals_ref[i], self.signals_ut[i])\n            return (True, "No error")\n        except VcdSignalComparationError as e:\n            return (False, "{}".format(e))\n\n'}, '4': {'filename': 'decoder_ref.v', 'content': b"\nmodule decoder(\n    input [2:0] x,\n    output reg [7:0] y\n    );\n    always @ (*) begin\n        case (x)\n        3'b000: y=8'b0000_0001;\n        3'b001: y=8'b0000_0010;\n        3'b010: y=8'b0000_0100;\n        3'b011: y=8'b0000_1000;\n        3'b100: y=8'b0001_0000;\n        3'b101: y=8'b0010_0000;\n        3'b110: y=8'b0100_0000;\n        3'b111: y=8'b1000_0000;\n        endcase\n    end\nendmodule\n"}, '5': {'filename': 'decoder.v', 'content': b"\nmodule decoder(\n    input [2:0] x,\n    output reg [7:0] y\n    );\n    always @ (*) begin\n        case (x)\n        3'b000: y=8'b0000_0001;\n        3'b001: y=8'b0000_0010;\n        3'b010: y=8'b0000_0100;\n        3'b011: y=8'b0000_1000;\n        3'b100: y=8'b0001_0000;\n        3'b101: y=8'b0010_0000;\n        3'b110: y=8'b0100_0000;\n        3'b111: y=8'b1000_0000;\n        endcase\n    end\nendmodule\n"}}}