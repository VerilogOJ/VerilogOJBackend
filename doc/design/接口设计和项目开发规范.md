# 接口设计和项目开发规范

本文档根据数据库&页面设计，用户故事和权限设计文档综合而成，主要描述系统中较高层次的接口。

## TODO

- 代码的文件夹规范
- Code of Conduct
- 单元测试规范
- 集成测试规范
- ...（Lookup in jsk & courseware & book）

## 组件一览

- 前端组件
- 后端组件
- 数据库组件
- 任务队列组件
- 文件管理组件
- 判题服务组件



### 前端组件 + 后端组件

> （LZT）需要讨论...我还不是特别熟悉 Vue + Django 开发的流程，瞎写估计会坑人



### 数据库组件

> 复核一下`数据库设计.md`？

### 文件管理组件

> 这里要讨论一下，到底应不应该直接用数据库存文件
>
> 对象存储的缺点是，可能增加开发复杂度
>
> 这个复杂度是我们需要的吗？

文件管理组件负责跟踪系统中用到的所有用户（判题/写题）的文件。

文件管理组件会被后端和判题服务组件调用。

判题服务组件可能运行在其它机器上，所以下面的接口需要在不同的服务器上都可以访问。

> （自我吐槽：似乎下面的操作不是很必要，直接传到后端暂存，后端再传到文件服务器也没啥毛病。。。或者都一台机器也可以。。）
>
> 上传文件的时候，上传的文件不需要经过后端（否则后端就成为了新的瓶颈），而是直接上传给文件管理组件中的文件服务器。然而，用户并不能随意上传文件，上传文件需要经过后端的同意。
>
> 所以，以做题上传为例：
>
> 1. 提交题目时，用户向后端提出上传文件的请求
> 2. 后端组件向文件管理组件申请请求签名，文件管理组件返回签名和 UUID 并交给后端，后端交给前端
> 3. 前端组件拿着签名和相关参数向文件管理组件的文件管理服务器发送 POST 请求，上传文件结束
> 4. 前端通知后端自己已经上传完毕，后端用文件 UUID 查询，确认完毕后，更新自己的状态
> 5. 后端通知前端将上传完毕的文件信息加以显示

> 关于请求签名等概念可以参考 http://www.dataguru.cn/article-14000-1.html

> （LZT）也许应该问问 FPGA OL 是怎么管理 Bitstream 的？（还是他们不管理呢）
>
> 为什么要有文件管理组件，而不是全存进数据库：
>
> - 需要支持 .v 和 .zip 两种
>   - .v 存进数据库尚可
>   - .zip 可能会让数据库体积膨胀的很厉害
> - 软件工程实践上的弱点（https://softwareengineering.stackexchange.com/questions/150669/is-it-a-bad-practice-to-store-large-files-10-mb-in-a-database）
>   - 性能劣势：
>     - 更大的数据库做 SELECT 更慢
>     - 从数据库读文件就没法用 `sendfile()` 等 Filesystem 直接到 Socket 的优化了
>   - 可扩展性劣势：
>     - 存进数据库意味着做横向扩展的难度增加
>     - 更难迁移到云厂商的对象存储服务
>
> 数据库方案的优点：
>
> - 数据库可以自己保证 ACID，不用我们额外关注原子性问题
>   - 不会有一个 orphaned 的文件
>   - 要么都成功，要么都失败
>
> （LZT）实现建议：可以基于 MinIO（https://www.min.io/） 封装一下？不是很确定

文件管理组件以单文件为单位，每个文件拥有一个 UUID，并且提供以下接口：

- auth(token)

  调用下面的 API 之前必须输入认证 token 才能继续

- get_file_info(file_uuid)

  返回如下字典：

  - filename
  - filesize
  - last-modified

- make_request(file_uuid)

  返回一个构造好的文件请求，类似 Python 的 requests

  request 的方法如下：

  - get() 获得文件句柄

- delete_file(file_uuid)

- upload_file(file_handle)

  返回一个 file_uuid，或者返回上传失败（则没有 UUID）

（需要讨论）

### 任务队列组件

任务队列组件负责接收从后端组件发送的判题任务，同时将任务发往判题服务组件。

任务队列组件可以对这些判题任务进行调度，跟踪判题任务的当前状态，并定期通知后端组件判题任务的进展。

#### 任务抽象

一个任务由如下几个部分构成：

- 用户相关信息（environ）

  - user: 被评测的用户的用户名

- 用于评测的文件（file）

  - file_uuid: 在文件管理组件中，标识文件的唯一 UUID

  > 这个文件可以是一个 .v 也可以是一个 .zip

- 用于评测的参数（judger）

  - time_limit: 评测最大时间限制
  - mem_limit: 评测最大内存限制
  - script_uuid: 评测所需脚本在文件管理组件中的唯一 UUID

  > 这里也是 UUID 而不是直接硬写进去的原因如下：
  >
  > - 随着时间推移可能会有大量的文件
  > - 文件不宜直接存进数据库
  > - 文件需要跟踪引用，当没有其它部分再需要这个文件时就应该删除
  >
  > （LZT）我觉得文件跟踪引用的部分交给后端来实现就可以，文件管理组件只需要根据 UUID 取文件就行。

#### 接口

- submit_task(environ, file, judger)

  返回一个 Task UUID

- get_result(uuid)

  返回一个结果字典：

  - status: 
    - SUCCESS
    - COMPILE_ERROR
    - INTERNAL_ERROR
    - ...（这里需要再讨论）
  - log: 过程中的日志
  - score: 分数


### 判题服务组件

> TODO

#### 输出

